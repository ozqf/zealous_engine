#ifndef SANDBOX_SHADERS_H
#define SANDBOX_SHADERS_H
/* This file is automatically generated */
//////////////////////////////////////////////////
// batch_quad_test_frag.glsl
//////////////////////////////////////////////////
static const char* batch_quad_test_frag_text =
"#version 330\n"
"\n"
"uniform int u_instanceCount;\n"
"\n"
"// flat - no interpolation\n"
"flat in int m_instanceID;\n"
"\n"
"out vec4 outputColor;\n"
"\n"
"void main()\n"
"{\n"
"    float r = float(m_instanceID) / float(u_instanceCount);\n"
"    float g = 1.0 - float(m_instanceID) / float(u_instanceCount);\n"
"    outputColor = vec4(r, g, 1, 1);\n"
"}\n"
"\n"
;
//////////////////////////////////////////////////
// batch_quad_test_vert.glsl
//////////////////////////////////////////////////
static const char* batch_quad_test_vert_text =
"#version 330\n"
"\n"
"uniform mat4 u_projection;\n"
"uniform int u_instanceCount;\n"
"\n"
"layout (location = 0) in vec3 i_position;\n"
"layout (location = 1) in vec2 i_uv;\n"
"layout (location = 2) in vec3 i_normal;\n"
"\n"
"out vec2 m_texCoord;\n"
"out vec3 m_normal;\n"
"out vec3 m_fragPos;\n"
"// flat - no interpolation\n"
"flat out int m_instanceID;\n"
"\n"
"void main()\n"
"{\n"
"    // pass instance to frag shader\n"
"    m_instanceID = gl_InstanceID;\n"
"\n"
"    mat4 u_modelView = u_projection;\n"
"\n"
"    u_modelView[0][0] *= 0.5;\n"
"    u_modelView[1][1] *= 0.5;\n"
"    u_modelView[2][2] *= 0.5;\n"
"\n"
"    // setup a hard-coded position\n"
"    if (gl_InstanceID == 0)\n"
"    {\n"
"        u_modelView[3][0] = -0.5;\n"
"        u_modelView[3][1] = -0.5;\n"
"    }\n"
"    else if (gl_InstanceID == 1)\n"
"    {\n"
"        u_modelView[3][0] = 0.5;\n"
"        u_modelView[3][1] = -0.5;\n"
"    }\n"
"    else if (gl_InstanceID == 2)\n"
"    {\n"
"        u_modelView[3][0] = 0.5;\n"
"        u_modelView[3][1] = 0.5;\n"
"    }\n"
"    else if (gl_InstanceID == 3)\n"
"    {\n"
"        u_modelView[3][0] = -0.5;\n"
"        u_modelView[3][1] = 0.5;\n"
"    }\n"
"\n"
"    vec4 positionV4 = vec4(i_position, 1.0);\n"
"    gl_Position = u_projection * u_modelView * positionV4;\n"
"    m_texCoord = i_uv;\n"
"	m_normal = normalize(mat3(u_modelView) * i_normal);\n"
"	m_fragPos = vec3(u_modelView * positionV4);\n"
"}\n"
"\n"
;
//////////////////////////////////////////////////
// draw_sprite_batch_2_vert.glsl
//////////////////////////////////////////////////
static const char* draw_sprite_batch_2_vert_text =
"#version 330\n"
"\n"
"uniform mat4 u_projection;\n"
"uniform mat4 u_view;\n"
"// uniform int u_instanceCount;\n"
"uniform sampler2D u_dataTexture;\n"
"uniform int u_dataStride;\n"
"uniform int u_dataTexSize;\n"
"uniform int u_isBillboard;\n"
"\n"
"layout (location = 0) in vec3 i_position;\n"
"layout (location = 1) in vec2 i_uv;\n"
"layout (location = 2) in vec3 i_normal;\n"
"\n"
"out vec2 m_texCoord;\n"
"out vec3 m_normal;\n"
"out vec3 m_fragPos;\n"
"// flat - no interpolation\n"
"flat out int m_instanceID;\n"
"flat out vec4 m_colour;\n"
"\n"
"ivec2 DataIndexToPixel(int index, int imageWidth)\n"
"{\n"
"	return ivec2(index % imageWidth, int(index / imageWidth));\n"
"}\n"
"\n"
"vec4 ReadDataPixel(int dataItemNumber)\n"
"{\n"
"    int root = u_dataStride * m_instanceID;\n"
"    ivec2 pixel = DataIndexToPixel(root + dataItemNumber, u_dataTexSize);\n"
"    return texelFetch(u_dataTexture, pixel, 0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    // pass instance to frag shader\n"
"    m_instanceID = gl_InstanceID;\n"
"\n"
"    // read instance data\n"
"    vec4 data1 = ReadDataPixel(0);\n"
"    vec4 data2 = ReadDataPixel(1);\n"
"    \n"
"    mat4 u_model;\n"
"    \n"
"    u_model[0][0] = 0.1; // scale x\n"
"    u_model[0][1] = 0;\n"
"    u_model[0][2] = 0;\n"
"    u_model[0][3] = 0;\n"
"\n"
"    u_model[1][0] = 0;\n"
"    u_model[1][1] = 0.1; // scale y\n"
"    u_model[1][3] = 0;\n"
"    u_model[1][2] = 0;\n"
"\n"
"    u_model[2][0] = 0;\n"
"    u_model[2][1] = 0;\n"
"    u_model[2][2] = 0.1; // scale z\n"
"    u_model[2][3] = 0;\n"
"    \n"
"    u_model[3][0] = data1.x; // pos x\n"
"    u_model[3][1] = data1.y; // pos y\n"
"    u_model[3][2] = data1.z; // pos z\n"
"    u_model[3][3] = 1;      // pos w\n"
"                        \n"
"    mat4 u_modelView = u_view * u_model;\n"
"    \n"
"    vec4 positionV4 = vec4(i_position, 1.0);\n"
"    if (u_isBillboard == 0)\n"
"    {\n"
"        // regular 3d\n"
"        gl_Position = u_projection * u_modelView * positionV4;\n"
"    }\n"
"    else\n"
"    {\n"
"        // reset rotation\n"
"        vec3 scale;\n"
"		mat4 mv = u_modelView;\n"
"		scale.x = length(mv[0].xyz);\n"
"		scale.y = length(mv[1].xyz);\n"
"		scale.z = length(mv[2].xyz);\n"
"		mv[0].xyz = vec3(1, 0, 0) * scale.x;\n"
"		mv[1].xyz = vec3(0, 1, 0) * scale.y;\n"
"		mv[2].xyz = vec3(0, 0, 1) * scale.z;\n"
"		gl_Position = u_projection * mv * positionV4;\n"
"    }\n"
"    \n"
"    m_texCoord.x = data2.x + ((data2.z - data2.x) * i_uv.x);\n"
"    m_texCoord.y = data2.y + ((data2.w - data2.y) * i_uv.y);\n"
"	m_normal = normalize(mat3(u_modelView) * i_normal);\n"
"	m_fragPos = vec3(u_modelView * positionV4);\n"
"}\n"
"\n"
;
//////////////////////////////////////////////////
// draw_sprite_batch_3_vert.glsl
//////////////////////////////////////////////////
static const char* draw_sprite_batch_3_vert_text =
"#version 330\n"
"\n"
"#define DEG2RAD 0.0174532925\n"
"\n"
"uniform mat4 u_projection;\n"
"uniform mat4 u_view;\n"
"// uniform int u_instanceCount;\n"
"uniform sampler2D u_dataTexture;\n"
"uniform int u_dataStride;\n"
"uniform int u_dataTexSize;\n"
"uniform int u_isBillboard;\n"
"\n"
"layout (location = 0) in vec3 i_position;\n"
"layout (location = 1) in vec2 i_uv;\n"
"layout (location = 2) in vec3 i_normal;\n"
"\n"
"out vec2 m_texCoord;\n"
"out vec3 m_normal;\n"
"out vec3 m_fragPos;\n"
"// flat - no interpolation\n"
"flat out int m_instanceID;\n"
"flat out vec4 m_colour;\n"
"\n"
"ivec2 DataIndexToPixel(int index, int imageWidth)\n"
"{\n"
"	return ivec2(index % imageWidth, int(index / imageWidth));\n"
"}\n"
"\n"
"vec4 ReadDataPixel(int dataItemNumber)\n"
"{\n"
"    int root = u_dataStride * m_instanceID;\n"
"    ivec2 pixel = DataIndexToPixel(root + dataItemNumber, u_dataTexSize);\n"
"    return texelFetch(u_dataTexture, pixel, 0);\n"
"}\n"
"\n"
"mat4 CreateScaleM4x4(float x, float y, float z)\n"
"{\n"
"    mat4 m;\n"
"    m[0][0] = x; // scale x\n"
"    m[0][1] = 0;\n"
"    m[0][2] = 0;\n"
"    m[0][3] = 0;\n"
"\n"
"    m[1][0] = 0;\n"
"    m[1][1] = y; // scale y\n"
"    m[1][3] = 0;\n"
"    m[1][2] = 0;\n"
"\n"
"    m[2][0] = 0;\n"
"    m[2][1] = 0;\n"
"    m[2][2] = z; // scale z\n"
"    m[2][3] = 0;\n"
"    \n"
"    m[3][0] = 0;            // pos x\n"
"    m[3][1] = 0;            // pos y\n"
"    m[3][2] = 0;            // pos z\n"
"    m[3][3] = 1;            // pos w\n"
"    return m;\n"
"}\n"
"\n"
"mat4 CreateRotateM4x4(float radians)\n"
"{\n"
"    mat4 rot;\n"
"    rot[0][0] = cos(radians);\n"
"    rot[0][1] = sin(radians);\n"
"    rot[0][2] = 0;\n"
"    rot[0][3] = 0;\n"
"\n"
"    rot[1][0] = -sin(radians);\n"
"    rot[1][1] = cos(radians);\n"
"    rot[1][2] = 0;\n"
"    rot[1][3] = 0;\n"
"\n"
"    rot[2][0] = 0;\n"
"    rot[2][1] = 0;\n"
"    rot[2][2] = 1;\n"
"    rot[2][3] = 0;\n"
"\n"
"    rot[3][0] = 0;\n"
"    rot[3][1] = 0;\n"
"    rot[3][2] = 0;\n"
"    rot[3][3] = 1;\n"
"    return rot;\n"
"}\n"
"\n"
"vec3 RotateSpritVertex(vec3 pos, float radians)\n"
"{\n"
"    mat3 rot;\n"
"    rot[0][0] = cos(radians);\n"
"    rot[0][1] = sin(radians);\n"
"    rot[0][2] = 0;\n"
"\n"
"    rot[1][0] = -sin(radians);\n"
"    rot[1][1] = cos(radians);\n"
"    rot[1][2] = 0;\n"
"\n"
"    rot[2][0] = 0;\n"
"    rot[2][1] = 0;\n"
"    rot[2][2] = 1;\n"
"    return pos * rot;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    // pass instance to frag shader\n"
"    m_instanceID = gl_InstanceID;\n"
"\n"
"    // read instance data\n"
"    vec4 data1 = ReadDataPixel(0);\n"
"    vec4 data2 = ReadDataPixel(1);\n"
"    vec4 data3 = ReadDataPixel(2);\n"
"    \n"
"    mat4 u_model;\n"
"    /*\n"
"    u_model[0][0] = data3.x; // scale x\n"
"    u_model[0][1] = 0;\n"
"    u_model[0][2] = 0;\n"
"    u_model[0][3] = 0;\n"
"\n"
"    u_model[1][0] = 0;\n"
"    u_model[1][1] = data3.y; // scale y\n"
"    u_model[1][3] = 0;\n"
"    u_model[1][2] = 0;\n"
"\n"
"    u_model[2][0] = 0;\n"
"    u_model[2][1] = 0;\n"
"    u_model[2][2] = 1; // scale z\n"
"    u_model[2][3] = 0;\n"
"    \n"
"    u_model[3][0] = data1.x;    // pos x\n"
"    u_model[3][1] = data1.y;    // pos y\n"
"    u_model[3][2] = data1.z;    // pos z\n"
"    u_model[3][3] = 1;          // pos w\n"
"    */\n"
"    \n"
"    vec4 positionV4 = vec4(i_position, 1.0);\n"
"    // apply scale then rotate in model space\n"
"    mat4 scale = CreateScaleM4x4(data3.x, data3.y, 1);\n"
"    mat4 rot = CreateRotateM4x4(data1.w);\n"
"    positionV4 *= scale;\n"
"    positionV4 *= rot;\n"
"\n"
"    u_model[0][0] = 1; // scale x\n"
"    u_model[0][1] = 0;\n"
"    u_model[0][2] = 0;\n"
"    u_model[0][3] = 0;\n"
"\n"
"    u_model[1][0] = 0;\n"
"    u_model[1][1] = 1; // scale y\n"
"    u_model[1][3] = 0;\n"
"    u_model[1][2] = 0;\n"
"\n"
"    u_model[2][0] = 0;\n"
"    u_model[2][1] = 0;\n"
"    u_model[2][2] = 1; // scale z\n"
"    u_model[2][3] = 0;\n"
"    \n"
"    u_model[3][0] = data1.x;    // pos x\n"
"    u_model[3][1] = data1.y;    // pos y\n"
"    u_model[3][2] = data1.z;    // pos z\n"
"    u_model[3][3] = 1;          // pos w\n"
"    \n"
"    mat4 u_modelView = u_view * u_model;\n"
"    \n"
"    // vec4 positionV4 = vec4(RotateSpritVertex(i_position, 45 * DEG2RAD), 1.0);\n"
"    // vec4 positionV4 = vec4(i_position, 1.0);\n"
"    if (u_isBillboard == 0)\n"
"    {\n"
"        // regular 3d\n"
"        gl_Position = u_projection * u_modelView * positionV4;\n"
"    }\n"
"    else\n"
"    {\n"
"        // reset rotation\n"
"        vec3 scale;\n"
"		mat4 mv = u_modelView;\n"
"		scale.x = length(mv[0].xyz);\n"
"		scale.y = length(mv[1].xyz);\n"
"		scale.z = length(mv[2].xyz);\n"
"		mv[0].xyz = vec3(1, 0, 0) * scale.x;\n"
"		mv[1].xyz = vec3(0, 1, 0) * scale.y;\n"
"		mv[2].xyz = vec3(0, 0, 1) * scale.z;\n"
"		gl_Position = u_projection * mv * positionV4;\n"
"    }\n"
"    \n"
"    m_texCoord.x = data2.x + ((data2.z - data2.x) * i_uv.x);\n"
"    m_texCoord.y = data2.y + ((data2.w - data2.y) * i_uv.y);\n"
"	m_normal = normalize(mat3(u_modelView) * i_normal);\n"
"	m_fragPos = vec3(u_modelView * positionV4);\n"
"}\n"
"\n"
;
//////////////////////////////////////////////////
// draw_sprite_batch_frag.glsl
//////////////////////////////////////////////////
static const char* draw_sprite_batch_frag_text =
"#version 330\n"
"\n"
"uniform sampler2D u_diffuseTex;\n"
"uniform sampler2D u_dataTexture;\n"
"uniform int u_instanceCount;\n"
"\n"
"in vec2 m_texCoord;\n"
"in vec3 m_normal;\n"
"in vec3 m_fragPos;\n"
"\n"
"// flat - no interpolation\n"
"flat in int m_instanceID;\n"
"flat in vec4 m_colour;\n"
"\n"
"out vec4 outputColor;\n"
"\n"
"void main()\n"
"{\n"
"    #if 1\n"
"    vec4 diffuse = texture2D(u_diffuseTex, m_texCoord);\n"
"    outputColor = diffuse;\n"
"    #endif\n"
"\n"
"    #if 0\n"
"    vec4 diffuse = texture2D(u_diffuseTex, m_texCoord);\n"
"    float r = float(m_instanceID) / float(u_instanceCount);\n"
"    float g = 1.0 - float(m_instanceID) / float(u_instanceCount);\n"
"    outputColor = vec4(diffuse.x * r, diffuse.y * g, diffuse.b, 1);\n"
"    #endif\n"
"    \n"
"    #if 0\n"
"    // vec4 block = vec4(1, 1, 1, 1);\n"
"    // vec4 data1 = texelFetch(u_dataTexture, ivec2(m_instanceID, 0);\n"
"\n"
"    // vec4 diffuse = vec4(texelFetch(u_dataTexture, ivec2(m_instanceID, 0), 0));\n"
"    // vec4 diffuse = vec4(texelFetch(u_dataTexture, ivec2(0, 0), 0));\n"
"    // outputColor = (block * 0.5) + (m_colour * 0.5);\n"
"    outputColor = m_colour;\n"
"    #endif\n"
"}\n"
"\n"
;
//////////////////////////////////////////////////
// draw_sprite_batch_vert.glsl
//////////////////////////////////////////////////
static const char* draw_sprite_batch_vert_text =
"#version 330\n"
"\n"
"uniform mat4 u_projection;\n"
"uniform mat4 u_view;\n"
"// uniform int u_instanceCount;\n"
"uniform sampler2D u_dataTexture;\n"
"uniform int u_dataStride;\n"
"uniform int u_dataTexSize;\n"
"\n"
"layout (location = 0) in vec3 i_position;\n"
"layout (location = 1) in vec2 i_uv;\n"
"layout (location = 2) in vec3 i_normal;\n"
"\n"
"out vec2 m_texCoord;\n"
"out vec3 m_normal;\n"
"out vec3 m_fragPos;\n"
"// flat - no interpolation\n"
"flat out int m_instanceID;\n"
"flat out vec4 m_colour;\n"
"\n"
"ivec2 DataIndexToPixel(int index, int imageWidth)\n"
"{\n"
"	return ivec2(index % imageWidth, int(index / imageWidth));\n"
"}\n"
"\n"
"vec4 ReadDataPixel(int dataItemNumber)\n"
"{\n"
"    int root = u_dataStride * m_instanceID;\n"
"    ivec2 pixel = DataIndexToPixel(root + dataItemNumber, u_dataTexSize);\n"
"    return texelFetch(u_dataTexture, pixel, 0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    // pass instance to frag shader\n"
"    m_instanceID = gl_InstanceID;\n"
"\n"
"    // read instance data\n"
"    vec4 data1 = ReadDataPixel(0);\n"
"    vec4 data2 = ReadDataPixel(1);\n"
"    \n"
"    mat4 u_modelView = u_projection;\n"
"\n"
"    mat4 u_model;\n"
"    \n"
"    u_model[0][0] = 0.1; // scale x\n"
"    u_model[0][1] = 0;\n"
"    u_model[0][2] = 0;\n"
"    u_model[0][3] = 0;\n"
"\n"
"    u_model[1][0] = 0;\n"
"    u_model[1][1] = 0.1; // scale y\n"
"    u_model[1][3] = 0;\n"
"    u_model[1][2] = 0;\n"
"\n"
"    u_model[2][0] = 0;\n"
"    u_model[2][1] = 0;\n"
"    u_model[2][2] = 0.1; // scale z\n"
"    u_model[2][3] = 0;\n"
"    \n"
"    u_model[3][0] = data1.x; // pos x\n"
"    u_model[3][1] = data1.y; // pos y\n"
"    u_model[3][2] = data1.z; // pos z\n"
"    u_model[3][3] = 1;      // pos w\n"
"\n"
"    \n"
"    \n"
"    u_modelView[0][0] *= 0.02f;\n"
"    u_modelView[1][1] *= 0.02f;\n"
"    u_modelView[2][2] *= 0.02f;\n"
"\n"
"    // pos\n"
"    u_modelView[3][0] = data1.x;\n"
"    u_modelView[3][1] = data1.y;\n"
"    u_modelView[3][2] = data1.z;\n"
"    u_modelView[3][3] = 1;\n"
"    \n"
"    vec4 positionV4 = vec4(i_position, 1.0);\n"
"    // gl_Position = u_projection * u_modelView * positionV4;\n"
"    gl_Position = u_projection * u_model * u_view * positionV4;\n"
"    // m_texCoord = i_uv;\n"
"    // m_texCoord = vec2(0.25, 0.25);\n"
"    m_texCoord.x = data2.x + ((data2.z - data2.x) * i_uv.x);\n"
"    m_texCoord.y = data2.y + ((data2.w - data2.y) * i_uv.y);\n"
"	m_normal = normalize(mat3(u_modelView) * i_normal);\n"
"	m_fragPos = vec3(u_modelView * positionV4);\n"
"}\n"
"\n"
;
//////////////////////////////////////////////////
// sandbox_draw_screen_tiles_frag.glsl
//////////////////////////////////////////////////
static const char* sandbox_draw_screen_tiles_frag_text =
"#version 330\n"
"\n"
"uniform vec4 u_colour;\n"
"// uniform sampler2D u_diffuseTex;\n"
"uniform usampler2D u_tileDataTex;\n"
"uniform sampler2D u_lightsArrayTex;\n"
"\n"
"uniform int u_tilesWide;\n"
"uniform int u_tilesHigh;\n"
"\n"
"in vec2 m_texCoord;\n"
"in vec3 m_normal;\n"
"in vec3 m_fragPos;\n"
"\n"
"out vec4 outputColor;\n"
"\n"
"int FragPositionToTileIndex(vec3 fragPos, int tilesWide, int tilesHigh)\n"
"{\n"
"	// move frag screen x/y into 0-1 range\n"
"	float x = (fragPos.x + 1) / 2;\n"
"	float y = (fragPos.y + 1) / 2;\n"
"	// calculate grid x/y\n"
"	int gridX = int(x * tilesWide);\n"
"	int gridY = int(y * tilesHigh);\n"
"	// convert grid x/y to linear index\n"
"	int tileIndex = gridX + (gridY * tilesWide);\n"
"	return tileIndex;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	#if 0\n"
"	if ((int(gl_FragCoord.x) % 2) == 0 && (int(gl_FragCoord.y) % 2) == 0)\n"
"	{\n"
"		discard;\n"
"	}\n"
"	outputColor = u_colour;\n"
"	#endif\n"
"\n"
"	#if 0\n"
"	vec4 data = texelFetch(u_tileDataTex, ivec2(0, 0), 0);\n"
"	outputColor = data;\n"
"	// outputColor = vec4(0.5, 0.5, 0.5, 0.5);\n"
"	#endif\n"
"	\n"
"	#if 1\n"
"	/*\n"
"	// move frag screen x/y into 0-1 range\n"
"	float x = (m_fragPos.x + 1) / 2;\n"
"	float y = (m_fragPos.y + 1) / 2;\n"
"	// calculate grid x/y\n"
"	int gridX = int(x * u_tilesWide);\n"
"	int gridY = int(y * u_tilesHigh);\n"
"	// convert grid x/y to linear index\n"
"	int tileIndex = gridX + (gridY * u_tilesWide);\n"
"	*/\n"
"	int tileIndex = FragPositionToTileIndex(m_fragPos, u_tilesWide, u_tilesHigh);\n"
"	// fetch first data row - count of light indices\n"
"	vec4 data = texelFetch(u_tileDataTex, ivec2(0, tileIndex), 0);\n"
"	// texture is single channel so only red is set\n"
"	int count = int(data.x);\n"
"	\n"
"	vec4 result = vec4(0, 0, 0, 0);\n"
"	for (int i = 0; i < count; ++i)\n"
"	{\n"
"		// get light index\n"
"		vec4 tileLightData = texelFetch(u_tileDataTex, ivec2(i + 1, tileIndex), 0);\n"
"		int lightIndex = int(tileLightData.x);\n"
"		// retrieve light data\n"
"		vec4 lightData1 = texelFetch(u_lightsArrayTex, ivec2(0, lightIndex), 0);\n"
"		vec4 lightData2 = texelFetch(u_lightsArrayTex, ivec2(1, lightIndex), 0);\n"
"		vec3 lightPos = vec3(lightData1);\n"
"		float radius = lightData1.w;\n"
"		vec3 rgb = vec3(lightData2);\n"
"		float strength = lightData2.w;\n"
"		result += vec4(rgb, 1);\n"
"		// outputColor = vec4(rgb, 0.5);\n"
"		// apply\n"
"	}\n"
"	outputColor = result;\n"
"	/*\n"
"	if (count == 1)\n"
"	{\n"
"		outputColor = vec4(1, 0, 0, 0.5);\n"
"	}\n"
"	else if (count == 2)\n"
"	{\n"
"		outputColor = vec4(0, 1, 0, 0.5);\n"
"	}\n"
"	else if (count == 3)\n"
"	{\n"
"		outputColor = vec4(0, 0, 1, 0.5);\n"
"	}\n"
"	else if (count == 4)\n"
"	{\n"
"		outputColor = vec4(1, 1, 0, 0.5);\n"
"	}\n"
"	else if (count == 255)\n"
"	{\n"
"		outputColor = vec4(0, 1, 1, 0.5);\n"
"	}\n"
"	// oops\n"
"	else if (count == 0)\n"
"	{\n"
"		outputColor = vec4(1, 0, 1, 0.2);\n"
"	}\n"
"	else\n"
"	{\n"
"		outputColor = vec4(1, 1, 1, 0.2);\n"
"	}\n"
"	*/\n"
"	// data.y = 0;\n"
"	// data.z = 0;\n"
"	// data.w = 0;\n"
"	// outputColor = data;\n"
"	#endif\n"
"}\n"
"\n"
;
//////////////////////////////////////////////////
// sandbox_draw_single_mesh_frag.glsl
//////////////////////////////////////////////////
static const char* sandbox_draw_single_mesh_frag_text =
"#version 330\n"
"\n"
"uniform vec4 u_colour;\n"
"uniform sampler2D u_diffuseTex;\n"
"\n"
"in vec2 m_texCoord;\n"
"in vec3 m_normal;\n"
"in vec3 m_fragPos;\n"
"\n"
"out vec4 outputColor;\n"
"\n"
"void main()\n"
"{\n"
"   #if 0\n"
"   if ((int(gl_FragCoord.x) % 2) == 0 && (int(gl_FragCoord.y) % 2) == 0)\n"
"   {\n"
"      discard;\n"
"   }\n"
"   outputColor = u_colour;\n"
"   #endif\n"
"\n"
"   #if 1\n"
"   // move frag screen x/y into 0-1 range\n"
"   float x = (m_fragPos.x + 1) / 2;\n"
"   float y = (m_fragPos.y + 1) / 2;\n"
"   if (x < 0.5f)\n"
"   {\n"
"      if (y < 0.5f)\n"
"      {\n"
"         outputColor = vec4(1, 0, 0, 0.5);\n"
"      }\n"
"      else\n"
"      {\n"
"         outputColor = vec4(0, 1, 0, 0.5);\n"
"      }\n"
"   }\n"
"   else\n"
"   {\n"
"      if (y < 0.5f)\n"
"      {\n"
"         outputColor = vec4(1, 1, 0, 0.5);\n"
"      }\n"
"      else\n"
"      {\n"
"         // outputColor = vec4(1, 0, 1, 0.5);\n"
"         discard;\n"
"      }\n"
"   }\n"
"   #endif\n"
"\n"
"   #if 0\n"
"   float x = m_fragPos.x;\n"
"   float y = m_fragPos.y;\n"
"   vec4 colour = u_colour;\n"
"   colour.x *= x;\n"
"   colour.y *= y;\n"
"   outputColor = colour;\n"
"   #endif\n"
"}\n"
"\n"
;
//////////////////////////////////////////////////
// sandbox_draw_single_mesh_vert.glsl
//////////////////////////////////////////////////
static const char* sandbox_draw_single_mesh_vert_text =
"#version 330\n"
"\n"
"uniform mat4 u_projection;\n"
"uniform mat4 u_modelView;\n"
"// Vertex Attrib 0\n"
"layout (location = 0) in vec3 i_position;\n"
"// // Vertex Attrib 1\n"
"layout (location = 1) in vec2 i_uv;\n"
"// // Vertex Attrib 2\n"
"layout (location = 2) in vec3 i_normal;\n"
"\n"
"out vec2 m_texCoord;\n"
"out vec3 m_normal;\n"
"out vec3 m_fragPos;\n"
"\n"
"void main()\n"
"{\n"
"   vec4 positionV4 = vec4(i_position, 1.0);\n"
"   gl_Position = u_projection * u_modelView * positionV4;\n"
"   m_texCoord = i_uv;\n"
"	m_normal = normalize(mat3(u_modelView) * i_normal);\n"
"	m_fragPos = vec3(u_modelView * positionV4);\n"
"}\n"
"\n"
;

#endif // SANDBOX_SHADERS_H
